import{_ as e,o as a,c as i,a as d}from"./app-a6bbcd8f.js";const n={},r=d(`<p>配置文件详解</p><h2 id="unit" tabindex="-1"><a class="header-anchor" href="#unit" aria-hidden="true">#</a> Unit</h2><p>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感。</p><h2 id="includes" tabindex="-1"><a class="header-anchor" href="#includes" aria-hidden="true">#</a> INCLUDES</h2><p>会解析这些个includes的配置文件，多实例的情况可以把公用的配置文件提取出来</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">################################## INCLUDES ###################################</span>
<span class="token comment"># include /path/to/local.conf</span>
<span class="token comment"># include /path/to/other.conf</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="network" tabindex="-1"><a class="header-anchor" href="#network" aria-hidden="true">#</a> NETWORK</h2><h3 id="bind" tabindex="-1"><a class="header-anchor" href="#bind" aria-hidden="true">#</a> bind</h3><p>默认bind=127.0.0.1只接受本机的访问请求，不写无限制接受任何IP的访问，在生产环境要写应用服务器的地址，所以需要配置好。</p><h3 id="protected-mode" tabindex="-1"><a class="header-anchor" href="#protected-mode" aria-hidden="true">#</a> protected-mode</h3><p>本机访问保护模式，如果开启了protected-mode，在没有设置bind且没有设置密码的情况下，Redis只接受本机的请求</p><h3 id="port" tabindex="-1"><a class="header-anchor" href="#port" aria-hidden="true">#</a> port</h3><p>服务端口号，默认6379</p><h3 id="tcp-backlog" tabindex="-1"><a class="header-anchor" href="#tcp-backlog" aria-hidden="true">#</a> tcp-backlog</h3><p>设置tcp 的backlog, backlog 其实是一个连接队列，backlog队列总和=未完成三次握手队列＋已经完成三次握手队列。 在高并发环境下你需要一个高backlog值来避免客户端慢连接问题。</p><h3 id="timeout" tabindex="-1"><a class="header-anchor" href="#timeout" aria-hidden="true">#</a> timeout</h3><p>检测是否超时，默认0（永不超时）</p><h3 id="top-keepalive" tabindex="-1"><a class="header-anchor" href="#top-keepalive" aria-hidden="true">#</a> top-keepalive</h3><p>检测心跳，检测时未进行操作，结束，默认300s。</p><h2 id="general" tabindex="-1"><a class="header-anchor" href="#general" aria-hidden="true">#</a> GENERAL</h2><h3 id="daemonize" tabindex="-1"><a class="header-anchor" href="#daemonize" aria-hidden="true">#</a> daemonize</h3><p>是否为守护线程（守护线程，后台启动），默认否</p><h3 id="pidfile" tabindex="-1"><a class="header-anchor" href="#pidfile" aria-hidden="true">#</a> pidfile</h3><p>存放pid文件的位置，每个实例会产生不同的pid文件</p><h3 id="loglevel" tabindex="-1"><a class="header-anchor" href="#loglevel" aria-hidden="true">#</a> loglevel</h3><p>日志记录级别，Redis总共支持四个级别:debug、verbose、notice、warning，默认为notice 四个级别根据使用阶段来选择，生产环境选择notice或者warning</p><h3 id="logfile" tabindex="-1"><a class="header-anchor" href="#logfile" aria-hidden="true">#</a> logfile</h3><p>日志输出文件路径</p><h3 id="databases" tabindex="-1"><a class="header-anchor" href="#databases" aria-hidden="true">#</a> databases</h3><p>设定库的数量（16），可以使用SELECT &quot;dbid&quot;命令在连接上指定数据库id，默认数据库为0</p><h2 id="security" tabindex="-1"><a class="header-anchor" href="#security" aria-hidden="true">#</a> SECURITY</h2><h3 id="设置密码" tabindex="-1"><a class="header-anchor" href="#设置密码" aria-hidden="true">#</a> 设置密码</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#1. 打开注释</span>
requirepass foobared
<span class="token comment">#2. 连接redis客户端</span>
$ config get requirepass
$ config <span class="token builtin class-name">set</span> requirepass <span class="token string">&quot;123pass&quot;</span>
$ auth 123pass
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="limits" tabindex="-1"><a class="header-anchor" href="#limits" aria-hidden="true">#</a> LIMITS</h2><h3 id="maxclients" tabindex="-1"><a class="header-anchor" href="#maxclients" aria-hidden="true">#</a> maxclients</h3><p>设置redis同时可以与多少客户端进行连接，默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出&quot;max number of clients reached”以作回应。</p><h3 id="maxmemory" tabindex="-1"><a class="header-anchor" href="#maxmemory" aria-hidden="true">#</a> maxmemory</h3><ul><li>redis 可占用最大内存，必须设置（否则内存占满，会导致服务器宕机）</li><li>达到内存使用上限，Redis将会移除部分数据，移除策略见maxmemory-policy指定</li></ul><h3 id="maxmemory-policy" tabindex="-1"><a class="header-anchor" href="#maxmemory-policy" aria-hidden="true">#</a> maxmemory-policy</h3><p>常用淘汰策略LRU（LeastRecentlyUsed，最近最少使用），LFU（LeastFrequentlyUsed，最不常用），FIFO（First In First Out，先进先出）</p><ul><li>volatile-lru -&gt; 使用LRU 算法移除key，只对设置了过期时间的键;</li><li>allkeys-lru -&gt; 使用LRU 算法移除key，在所有集合key中;</li><li>volatile-lfu -&gt; 使用LFU 算法移除key，只对设置了过期时间的键;</li><li>allkeys-lfu -&gt; 使用LFU 算法移除key，在所有集合key中;</li><li>volatile-random -&gt; 在过期集合中移除随机的key;</li><li>allkeys-random -&gt; 在所有集合key中，移除随机的key;</li><li>volatile-ttl -&gt; 移除那些TTL值最小的key，即那些最近要过期的key;</li><li>noeviction -&gt; 不进行移除。针对写操作，只是返回错误信息;</li></ul>`,41),s=[r];function l(t,h){return a(),i("div",null,s)}const o=e(n,[["render",l],["__file","peizhi.html.vue"]]);export{o as default};
