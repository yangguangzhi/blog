import{_ as e,o as r,c as i,b as a,a as h,d}from"./app-a6bbcd8f.js";const n={},t=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"STW"),a("p",null,"STW(Stop The World)是指在执行垃圾回收的过程中，将JVM内存冻结，应用程序停顿的一种状态。 在STW状态下，JAVA的所有线程都是停止执行的，除了GC所需的线程外，其他线程都将停止工作，中断了应用程序的执行。 优化JVM实则就是减少STW的时间")],-1),l=h('<h2 id="垃圾对象" tabindex="-1"><a class="header-anchor" href="#垃圾对象" aria-hidden="true">#</a> 垃圾对象</h2><h3 id="根搜索算法" tabindex="-1"><a class="header-anchor" href="#根搜索算法" aria-hidden="true">#</a> 根搜索算法</h3><p>首先确定一系列肯定不能被回收的对象，即GC Roots。然后，从这些GC Roots出发，向下搜索，去寻找它直接和间接引用的对象。 最后，如果一个对象没有被GC Roots直接或间接地引用，那么这个对象就可以被回收了。</p><p>GC Roots</p><ul><li>虚拟机栈中的局部变量</li><li>方法区中的静态属性和常量</li><li>本地方法栈中的JNI引用</li></ul><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h3><p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明对象不是垃圾。而如果一个对象没有任何引用指向它，那么改对象就是垃圾对象。</p><h3 id="堆内存不足" tabindex="-1"><a class="header-anchor" href="#堆内存不足" aria-hidden="true">#</a> 堆内存不足</h3><p>当堆内存不足以满足新创建的对象时，也会触发垃圾回收，把新生代没有人引用的对象给回收掉，释放内存空间。</p><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h2><h3 id="标记-清除" tabindex="-1"><a class="header-anchor" href="#标记-清除" aria-hidden="true">#</a> 标记-清除</h3><p>通过根对象可达性分析找出所有存活的对象，然后标记这些对象；再清理未被标记的对象。 对象大小不一容易造成内存碎片</p><h3 id="标记-复制" tabindex="-1"><a class="header-anchor" href="#标记-复制" aria-hidden="true">#</a> 标记-复制</h3><p>将堆内存分为两个区域，每次只使用一块区域，当该区域用完时，将存活的对象复制到另一个区域中，然后清空原区域。 解决内存碎片问题，浪费了一半的存储空间</p><h3 id="标记-整理" tabindex="-1"><a class="header-anchor" href="#标记-整理" aria-hidden="true">#</a> 标记-整理</h3><p>通过根可达性分析找出所有存活的对象，然后把它们移动到堆的一端，然后清理另一端。 既解决了内存问题，又不需要额外的存储空间</p><h3 id="分带收集" tabindex="-1"><a class="header-anchor" href="#分带收集" aria-hidden="true">#</a> 分带收集</h3><p>根据对象的存活周期划分新生代和老年代，采用不同的垃圾回收算法。新生代通常使用复制算法，老年代则使用标记-整理或标记-清除算法</p><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h2><h3 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器" aria-hidden="true">#</a> Serial收集器</h3><p>这是一个新生代的收集器，进行单线程的垃圾回收，最适用于小型应用和客户端应用。</p><h3 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器" aria-hidden="true">#</a> Parallel Scavenge收集器</h3><p>也是一个新生代收集器，它使用多线程进行垃圾回收，以达到较高的吞吐量。</p><h3 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器" aria-hidden="true">#</a> ParNew收集器</h3><p>类似于Parallel Scavenge收集器，也是多线程的新生代收集器，它可以与CMS收集器配合使用。</p><h3 id="serial-old收集器" tabindex="-1"><a class="header-anchor" href="#serial-old收集器" aria-hidden="true">#</a> Serial Old收集器</h3><p>属于老年代收集器，它使用单线程【标记-整理算法】进行垃圾回收，主要用于配合新生代的Serial和ParNew收集器。</p><h3 id="parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old收集器" aria-hidden="true">#</a> Parallel Old收集器</h3><p>是老年代的多线程收集器，主要用于搭配新生代的Parallel Scavenge收集器。 回收过程中使用的是标记-整理算法，可以使得内存空间得到充分利用，避免了内存碎片的问题。适用于注重于吞吐量及CPU资源敏感的场合。</p><h3 id="cms-concurrent-mark-sweep-收集器" tabindex="-1"><a class="header-anchor" href="#cms-concurrent-mark-sweep-收集器" aria-hidden="true">#</a> CMS（Concurrent Mark Sweep）收集器</h3><p>主要应用于老年代的垃圾回收，是一种以获取最短回收停顿时间为目标的收集器。 回收过程使用并发标记-清除算法【该算法执行过程中会与应用程序并发执行，将垃圾对象标记，然后在清除阶段回收这些对象】，适用于对响应时间有严格要求的应用。</p>',31),s=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"TIP"),a("p",null,"由于CMS使用的是标记清除算法，容易产生内存碎片，导致大对象无法分配问题，就会触发FullGC。 CMS提供了一个参数：【-XX:+UseCMSCompactAtFullCollection】在进行FullGC之前进行一次内存整理")],-1),o=a("h3",{id:"g1-garbage-first-收集器",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#g1-garbage-first-收集器","aria-hidden":"true"},"#"),d(" G1（Garbage-First）收集器")],-1),c=a("p",null,"一款面向服务端应用的垃圾收集器，它将堆内存划分成多个大小相同的Region，每个Region可以是Eden区、Survivor区或Old区， 回收过程使用并发标记-整理算法，可以精确控制暂停时间。G1回收器适用于新生代和老年代。",-1),p=[t,l,s,o,c];function u(x,f){return r(),i("div",null,p)}const g=e(n,[["render",u],["__file","JVMlajishouji.html.vue"]]);export{g as default};
