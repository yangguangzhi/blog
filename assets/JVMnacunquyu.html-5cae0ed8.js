import{_ as i,o as e,c as n,b as l,d as a,a as t}from"./app-a6bbcd8f.js";const r={},o=l("div",{class:"custom-container tip"},[l("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[l("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[l("circle",{cx:"12",cy:"12",r:"9"}),l("path",{d:"M12 8h.01"}),l("path",{d:"M11 12h1v4h1"})])]),l("p",{class:"custom-container-title"},"TIP"),l("p",null,"线程私有"),l("ul",null,[l("li",null,"VM Stack【虚拟机栈】"),l("li",null,"Native Method Stack【本地方法栈】"),l("li",null,"Program Counter Register【程序计数器】")]),l("p",null,"线程共享"),l("ul",null,[l("li",null,"Method Area【方法区】"),l("li",null,"Heap【堆】")])],-1),s=l("h2",{id:"虚拟机栈",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#虚拟机栈","aria-hidden":"true"},"#"),a(" 虚拟机栈")],-1),c=l("p",null,"描述方法执行的内存模型，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应Java一次次的方法调用",-1),u=l("ul",null,[l("li",null,"方法执行的同时，会在虚拟机栈中创建一个栈帧"),l("li",null,"方法过多可能导致栈/内存溢出异常")],-1),h=l("div",{class:"custom-container tip"},[l("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[l("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[l("circle",{cx:"12",cy:"12",r:"9"}),l("path",{d:"M12 8h.01"}),l("path",{d:"M11 12h1v4h1"})])]),l("p",{class:"custom-container-title"},"栈帧"),l("p",null,"int num = 10;"),l("ul",null,[l("li",null,"方法局部变量表，num就是局部变量表一员；"),l("li",null,"操作数据栈，10就是操作数据栈一员"),l("li",null,"动态链接，符号引用在实际使用时转换成直接引用"),l("li",null,"方法出口，方法调用过程中的返回值处理")])],-1),d=t('<h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><p>原理结构和虚拟机栈一致，不同点：</p><ul><li>虚拟机栈存放的是JRE和开发人员自己编写的方法</li><li>本地方法栈存放的是操作系统底层的方法</li></ul><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h2><p>行号显示器，指向当前线程所执行的字节码指定地址（class文件的行号）， 线程被创建时，程序计数器值为0，每当执行一条字节码指令，程序计数器的值就会自动+1， 指向下一条要执行的字节码指令。程序计数器为-1表示线程要退出了。</p><ul><li>程序计数器是class文件的行号，但如果是native方法，程序计数器的值为undefined</li><li>唯一不会产生内存溢出的区域</li><li>Java中保留字<code>goto</code>，其本质就是改变程序计数器的值</li></ul><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h2><ul><li>存放 <ul><li>类的元数据【类的版本、字段、方法、接口描述】</li><li>常量</li><li>静态变量</li></ul></li><li>GC <ul><li>类的元数据</li><li>常量</li></ul></li></ul><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><p>存放对象的实例（数组、对象）</p><h3 id="运行时内存分布" tabindex="-1"><a class="header-anchor" href="#运行时内存分布" aria-hidden="true">#</a> 运行时内存分布</h3><ul><li>新生代（1/3） <ul><li>Eden（8/10）</li><li>Survival From（1/10）</li><li>Survival To（1/10）</li></ul></li><li>老年代（2/3）</li><li>元空间，存放类的元数据</li></ul><h3 id="新生代和老年代" tabindex="-1"><a class="header-anchor" href="#新生代和老年代" aria-hidden="true">#</a> 新生代和老年代</h3><p>特点</p><ul><li>新生代的使用率在9层，在使用时两块Survival区域只能用一块（复制算法，为了避免过多碎片产生）</li><li>新生代存放生命周期短的对象和小对象</li><li>老年代存放生命周期上的对象和大对象（大对象集合、数组、字符串）</li><li>大部分对象都存放在新生代中，新生代的回收频率高、效率高</li><li>老年代空间大、增速慢、回收频率低</li></ul><p>新生代和老年代更替</p><ol><li>MinorGC，用来回收新生代的对象</li><li>Eden中的对象在进行一次回收后仍然存活的对象，就会转移到Survival中</li><li>MinorGC再次回收，Survival中仍然存货的对象年龄+1（对象头用4位存放年龄，15阈值）， 超过阈值就会转移到老年代</li><li>老年代的回收器：MajorGC、FullGC</li></ol>',17),p=l("div",{class:"custom-container tip"},[l("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[l("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[l("circle",{cx:"12",cy:"12",r:"9"}),l("path",{d:"M12 8h.01"}),l("path",{d:"M11 12h1v4h1"})])]),l("p",{class:"custom-container-title"},"直接内存"),l("p",null,"一种特殊类型的内存，它不属于堆内存、栈内存和元空间等传统的Java虚拟机内存区域。直接内存可以让Java程序在运行时使用比堆内存更大的内存空间，并且不需要进行垃圾回收。"),l("p",null,"直接内存可以通过使用NIO包中的ByteBuffer类的allocateDirect() 方法来申请。直接内存的申请大小不受限制，但是需要注意，直接内存的使用需要手动管理，包括释放和重新分配等操作。")],-1),v=[o,s,c,u,h,d,p];function w(x,_){return e(),n("div",null,v)}const m=i(r,[["render",w],["__file","JVMnacunquyu.html.vue"]]);export{m as default};
