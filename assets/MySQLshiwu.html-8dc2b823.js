import{_ as l,o as e,c as i,a}from"./app-a6bbcd8f.js";const o={},d=a('<p>Innodb引擎支持事务</p><h2 id="事务怎么实现" tabindex="-1"><a class="header-anchor" href="#事务怎么实现" aria-hidden="true">#</a> 事务怎么实现</h2><p>Innodb通过Undo Log实现将数据恢复到事务执行前的状态；</p><p>一条update语句执行流程</p><ol><li>Innodb在收到一个update语句时，会先根据条件找到数据所在的page，并将该page缓存在BufferPool中</li><li>执行update语句，修改BufferPool中的数据</li><li>针对update语句生成一个RedoLog对象，并存人BufferPool</li><li>针对update语句生成undoLog日志<code>用于事务回滚</code></li><li>如果事务提交，那么就将RedoLog对象进行持久化</li><li>如果事务回滚，则利用undoLog进行回滚</li></ol><h2 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h2><ul><li>原子性</li></ul><p>事务是一个不可分割的工作单位，要么全部执行成功，要么全部失败回滚。 在事务执行过程中，如果其中任何一个SQL语句执行失败，则整个事务将回滚到初始状态，所有已经执行成功的SQL语句也将被撤销。</p><ul><li>一致性</li></ul><p>事务必须使数据库从一个一致性状态转换到另一个一致性状态。在事务执行过程中，只有符合一致性约束条件的操作才会被执行，否则将被回滚。</p><ul><li>隔离性</li></ul><p>多个并发事务之间相互独立，互不干扰。一个事务的中间状态对其他事务是不可见的，即通过设置事务的隔离级别可以控制事务之间的可见性和影响范围。</p><ul><li>持久性</li></ul><p>一旦事务提交，其修改的数据将被永久保存到数据库中，即使系统崩溃或断电也不会丢失。</p><h2 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h2><ul><li>读未提交</li></ul><p>允许事务读取尚未提交的其他事务的修改。 这种隔离级别的强度最低，但并发性能最好。可能会导致脏读、不可重复读和幻读问题。</p><ul><li>读已提交</li></ul><p>只允许事务读取已经提交的其他事务的修改。 这种隔离级别可以避免脏读问题，但仍然可能出现不可重复读和幻读问题。</p><ul><li>可重复读</li></ul><p>MySQL的默认隔离级别，对同一字段的多次读取结果都是一致的，除非事务本身发生改变。 这种隔离级别可以避免脏读和不可重复读问题，但仍然可能出现幻读问题。</p><ul><li>串行化</li></ul><p>强制事务串行执行，避免了脏读、不可重复读和幻读问题。 但是这种隔离级别的并发性能最差</p>',23),u=[d];function p(n,t){return e(),i("div",null,u)}const c=l(o,[["render",p],["__file","MySQLshiwu.html.vue"]]);export{c as default};
