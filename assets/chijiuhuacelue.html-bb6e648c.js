import{_ as a,o as i,c as l,b as n,d as s,a as e}from"./app-a6bbcd8f.js";const o={},c=n("h2",{id:"rdb-redis-database",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#rdb-redis-database","aria-hidden":"true"},"#"),s(" RDB（Redis Database）")],-1),t=n("p",null,"RDB持久化策略是一种以内存快照形式保存Redis数据的方式。持久化默认名dump.rdb",-1),d=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"TIP"),n("p",null,"快照，就是把某一时刻的状态以文件的形式进行全面备份到磁盘，这个快照文件就称为RDB文件。")],-1),r=e(`<ol><li>在指定时间间隔内将内存中的数据集以快照的形式写入磁盘</li><li>间隔时间写入的特点会导致RDB最后一次持久化的数据可能丢失，内存中的数据可能会因为某些原因（例如断电、系统崩溃等）而丢失。</li><li>RDB持久化时，会fork一个子线程来进行持久化（持久化交由子线程处理，父进程继续处理客户端的请求，即是写时复制）</li><li>持久化时会先将数据写入一个临时文件中，带持久化过程结束了，再用这个临时文件替换上次持久化好的文件</li></ol><h3 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dbfilename dump.rdb
<span class="token comment"># RDB的默认文件名</span>
<span class="token function">dir</span> ./
<span class="token comment"># RDB的默认保存路径，默认在Redis的安装目录下</span>
stop-writes-on-bgsave-error <span class="token function">yes</span>
<span class="token comment"># 当Redis无法写入磁盘的话，直接关闭Redis的写操作，推荐yes</span>
rdbcompression <span class="token function">yes</span>
<span class="token comment"># 快照压缩（LZF算法），如果不想消耗CPU压缩可以关闭此功能，推荐yes</span>
rdbchecksum <span class="token function">yes</span>
<span class="token comment"># RDB完整性（CRC64算法）检查，校验会增加性能消耗，如果希望得到最大化的性能提升可以关闭此功能，推荐yes</span>

save <span class="token number">3600</span> <span class="token number">1</span> <span class="token comment"># 3600秒有一次key发生变化</span>
save <span class="token number">30</span> <span class="token number">10</span> <span class="token comment"># 30秒有一次key发生变化</span>
save <span class="token number">60</span> <span class="token number">10000</span> <span class="token comment"># 60秒10000次key发生变化</span>
<span class="token comment"># 指定时间间隔将快照落磁盘的配置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file" aria-hidden="true">#</a> AOF（Append Only File）</h2><p>AOF持久策略是一种通过记录每个写操作命令，然后将这些命令追加到AOF文件的方式来实现数据持久化的策略。</p><ol><li>以日志的形式来记录每个写操作（增量保存，读操作不会记录）</li><li>Redis启动时会读取该文件重新构建数据（根据日志文件，将写指令从头执行一遍）</li><li>重写机制，当AOF文件大小超过了配置值，Redis会创建一个新的AOF文件，将命令重写入新的AOF文件（清除冗余命令，不会影响数据）。</li><li>AOF重写会阻塞，因为需要等待整个AOF文件重写完之后才会返回客户端。</li></ol>`,6),p=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"如果遇到AOF文件损坏，可以尝试通过redis-check-aof"),n("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[n("pre",{class:"language-bash"},[n("code",null,[s("$ /usr/local/bin/redis-check-aof "),n("span",{class:"token parameter variable"},"--fix"),s(` appendonly.aof
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"})])])],-1),u=e(`<h3 id="aof写入策略" tabindex="-1"><a class="header-anchor" href="#aof写入策略" aria-hidden="true">#</a> aof写入策略</h3><ul><li>always，始终同步，每次Redis的写入都会立即写入日志；性能较差，但是能保证完整性</li><li>everysec，每秒同步，每秒写入一次日志，服务器如果发生宕机，就会丢失一秒的数据</li><li>no，Redis不主动进行同步，把同步操作移交给操作系统</li></ul><h3 id="配置-1" tabindex="-1"><a class="header-anchor" href="#配置-1" aria-hidden="true">#</a> 配置</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>
<span class="token comment"># aof默认文件名</span>
appendonly no
<span class="token comment"># 默认不开启aof</span>
appendfsync <span class="token punctuation">[</span>optional<span class="token punctuation">]</span>
<span class="token comment"># 写入频率【always、everysec、no】</span>
no-appendfsync-on-rewirte <span class="token function">yes</span>
<span class="token comment"># yes，不写入aof只写入缓存，用户请求不会阻塞，这段时间宕机会丢失这部分数据</span>
<span class="token comment"># no，还是会往磁盘刷数据，但是遇到重写操作可能会阻塞</span>
auto-aof-rewrite-percentage <span class="token number">100</span>
<span class="token comment"># aof重写基准值，文件达到100%开始重写（文件是原来重写文件的2倍时触发）</span>
auto-aof-rewrite-min-size 64mb
<span class="token comment"># aof重写基准值，最小文件64M，达到这个值开始重写</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),m=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"TIP"),n("p",null,"AOF 和RDB同时开启，系统默认读取AOF的数据（AOF的数据基本不会丢失）")],-1),v=[c,t,d,r,p,u,m];function h(b,k){return i(),l("div",null,v)}const w=a(o,[["render",h],["__file","chijiuhuacelue.html.vue"]]);export{w as default};
