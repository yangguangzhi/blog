import{_ as i,o as l,c as a,a as e}from"./app-a6bbcd8f.js";const r={},n=e('<h2 id="spring事务是如何实现的" tabindex="-1"><a class="header-anchor" href="#spring事务是如何实现的" aria-hidden="true">#</a> Spring事务是如何实现的</h2><ol><li>底层基于数据库事务和AOP机制</li><li>对于@Transactional的方法，Spring会创建一个代理对象来处理逻辑</li><li>当调用事务代理对象是，判断事务注解，如果存在则利用事务管理器创建一个数据库连接来处理事务</li><li>并修改当前连接的autocommit为false，禁止事务自动提交</li><li>执行当前方法中的sql</li><li>出现事务捕获异常，回滚当前事务，否则提交事务</li></ol><h2 id="事务传播机制" tabindex="-1"><a class="header-anchor" href="#事务传播机制" aria-hidden="true">#</a> 事务传播机制</h2><p>Spring的事务传播机制是基于数据库连接实现的，一个数据库连接一个事务，如果传播机制为需要开启一个新事务，那么实际上就是先建立一个新的数据库连接，在新的数据库连接上执行SQL，事务传播类型如下：</p><ul><li>REQUIRED，Spring事务默认的传播机制，如果当前没有事务就新建一个事务，如果当前存在事务，则加入这个事务。</li><li>SUPPORTS，当前存在事务就加入当前事务，如果当前不存在事务，就以非事务方法执行。</li><li>MANDATORY，当前存在事务就加入当前事务，如果当前事务不存在，则抛异常</li><li>REQUIRED_NEW，创建一个新事务，如果当前存在事务，就挂起该事务</li><li>NEVER，不使用事务，如果当前存在事务就抛异常</li><li>NESTED，如果当前存在事务就加入，否则开启一个新事务</li></ul><h2 id="事务失效" tabindex="-1"><a class="header-anchor" href="#事务失效" aria-hidden="true">#</a> 事务失效</h2><p>Spring事务的底层实现原理是AOP切面增强，失效的原因就是AOP机制不起作用了！常见情况如下</p><ul><li>类方法自调用，一个类里面使用this调用本类的方法（this通常也会省略），此时这个this不是代理对象，所以事务会失效</li><li>方法不是public修饰，@Transactional只能用于public修饰的方法上，这样的情况事务会失效。（如果非要在非public方法上，可以开启AspectJ代理模式）</li><li>数据库本身不支持事务</li><li>该方法没有被Spring所管理</li><li>异常被捕获，事务失效，或者抛出的异常和rollbackFor定义的异常不同（默认是RuntimeException）</li></ul>',8),t=[n];function c(s,h){return l(),a("div",null,t)}const p=i(r,[["render",c],["__file","Springshiwu.html.vue"]]);export{p as default};
