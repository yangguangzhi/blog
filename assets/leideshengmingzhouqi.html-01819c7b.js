import{_ as l,o as e,c as a,b as i,a as t}from"./app-a6bbcd8f.js";const r={},n=i("div",{class:"custom-container tip"},[i("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[i("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[i("circle",{cx:"12",cy:"12",r:"9"}),i("path",{d:"M12 8h.01"}),i("path",{d:"M11 12h1v4h1"})])]),i("p",{class:"custom-container-title"},"TIP"),i("p",null,"加载 >> 连接 >> 初始化 >> 使用 >> 卸载")],-1),s=t('<h2 id="加载" tabindex="-1"><a class="header-anchor" href="#加载" aria-hidden="true">#</a> 加载</h2><ul><li>查找并加载类的二进制数据（class文件）</li><li>将class文件，加载到JVM中</li></ul><h2 id="连接" tabindex="-1"><a class="header-anchor" href="#连接" aria-hidden="true">#</a> 连接</h2><h3 id="验证" tabindex="-1"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h3><ul><li>验证class文件的正确性</li></ul><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h3><ul><li>准备阶段，JVM中只有类没有对象</li><li>给static变量分配内存，并赋初始值（默认值）【这时final修饰的变量会立即赋值（使用随机数的情况除外）】</li><li>准备执行流程是static &gt;&gt; 非static &gt;&gt; 构造方法</li></ul><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h3><ul><li>将类的符号引用转换为直接引用</li><li>开始阶段并不知晓类的具体内存地址，暂用<code>com.pojo.xx</code>这样的符号引用来表示xx类</li><li>解析阶段，JVM将符号引用映射成实际的内存地址，之后就用内存地址（直接引用）来标识xx类</li></ul><h2 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h2><ul><li>给static变量赋真正的初始值</li></ul><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><ul><li>对象初始化、垃圾回收、销毁等</li></ul><h3 id="类的使用方式" tabindex="-1"><a class="header-anchor" href="#类的使用方式" aria-hidden="true">#</a> 类的使用方式</h3><p>类的初始化，JVM只有在首次主动使用一个类或接口时，才会初始化类</p><ol><li>创建类的实例（new）</li><li>访问某个类或者接口的静态变量，或者对该静态变量赋值</li><li>如果一个成员变量被final和static同时修饰，该类不会被初始化。但是如果这个变量的值是随机值，则会被初始化</li><li>反射 (比如： Class.forName(&quot;java.lang.String&quot;))</li><li>初始化一个类的子类，父类也会跟着初始化</li><li>动态代理所涉及到的类也会初始化</li><li>JVM启动时被标明为启动类的类</li></ol><h2 id="卸载" tabindex="-1"><a class="header-anchor" href="#卸载" aria-hidden="true">#</a> 卸载</h2><ul><li>由JVM内部加载器加载的类始终不会被卸载，用户自定义的加载器加载的类可以被卸载</li></ul>',18),h=i("div",{class:"custom-container tip"},[i("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[i("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[i("circle",{cx:"12",cy:"12",r:"9"}),i("path",{d:"M12 8h.01"}),i("path",{d:"M11 12h1v4h1"})])]),i("p",{class:"custom-container-title"},"JVM结束生命周期的时机"),i("ul",null,[i("li",null,"程序正常结束"),i("li",null,"程序异常结束"),i("li",null,"System.exit()"),i("li",null,"操作系统异常")])],-1),o=[n,s,h];function c(d,u){return e(),a("div",null,o)}const p=l(r,[["render",c],["__file","leideshengmingzhouqi.html.vue"]]);export{p as default};
